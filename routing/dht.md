## DHT

解决无中心化、海量数据、节点动态变化、查询效率 造成的难点，其核心算法如下：

- 1 散列算法

>选择>128 bit的哈希散列算法，降低哈希碰撞的概率。

- 2 同构NodeID与Data Key

>NodeID与Data Key相同是否属于碰撞呢？No

- 3 距离算法

- 4 路由算法

> 路由表大、实现跳数小、但是维护成本高

> 路由表小、实现跳数大、但是维护成本低

- 5 数据定位

> 保存数据：

> 若NodeID判断自己与Data Key的距离最小、则存储在自己的节点之上,否则，转发数据，一直将Data Value转发至离Data Key距离最小的节点之上。

> 获取数据：

>若NodeID判断自己与Data Key的距离最小、则从本节点获取数据，获取成功返回、获取失败报错,否则，转发获取请求，一直找到离Data Key的距离最小节点，获取数据。

##  IPFS中使用的DHT算法
- KAD 算法: 诞生于2002年，基于异或运算的P2P算法,算法复杂度LogN
- CORAL DSHT 算法
- S/KAD算法

##  KAD算法
- 散列值处理
NodeID、Data Key散列算法同构，均采用使用SHA-1(160bit)

- 最短唯一前缀 
	- 网络节点总数相对于2的160次方是一个非常小的合集，其实际散列值非常零散
	- 基于如上特点，nodeid或者data key的散列值是高度随机的，两者之间的不会非常临近
	- 使用最短唯一前缀会提高查找效率

- 最短唯一前缀表示，为便于后面的路由算法
	- 表示成二进制，由高位到低位映射树结构
	- 二进制的第n个数就为二叉树的第n层，（对应后面有n棵子树）
	- 为1进入左树、为0进入右树
	- 全部处理完，data key就处于整个二叉树的某个叶子节点上

![](/1.png) 

- 距离算法
基于异或运算，如d(x,y)表示x与y异或，其结果表示两者之间距离
符合如下特征：
	- d（x，x）=0
	- d（x，y）>0
	- d（x，y）=d（y,x）
	- d（a，b）+d（b，c）>d（a，c）
对于距离data key某一特定距离来说，其目标节点是固定的

- 路由算法1，二叉树映射
	- 每个特定的NodeID以自己的视角进行树的拆分
	- 从不包含自己的子树开始，直至只剩下自己，由左到右拆分，位于第N层的节点有N棵子树
	- KAD采用160bit的散列算法，基于其高度随机，子树数量可能远小于160棵
	- 若已知每棵子树种的一个节点，Node可以基于其n棵子树进行递归，便可以找到整棵树的任意节点。

![](/2.png) 

- 路由算法2——K桶
由上所述，拆分子树后，知道每个子树的任一节点，便可遍历到整棵树，但是依赖分布式系统的健壮性考虑（1个是不可靠的），每个节点需要记录记录多个节点，所记录的节点就叫做K桶。其大小可以自定义。K桶就相当于路由表。
BT使用的KAD K桶大小为K，表示其每棵子树路由表条数不能超过K
	- 距离越近的子树，桶条目数远小于K
	- 有些子树，节点数远大于K，但是那些节点没有被本根节点搜集到，桶条目数也会小于K。

如下为路由表及路由过程

![](/3.png) 

- 路由算法3——K桶刷新机制
> 主动刷新,  本地节点主动刷新，更新路由表

> 被动刷新, 其他节点发送请求给本地节点，请求更新路由表

>探测失效的节点,  探测路由表中的节点，失效则删除。

- 路由算法4——并发性能、α参数
  表示每次从一个子树K桶中请求节点的时候，同时最多请求α个节点，KAD协议默认为3。
  提高性能可以提高α参数

- 路由算法5——节点加入或退出
  - 加入
    - 任何一个新节点A加入，需要与KAD网络中的任意一个节点连接，假设为B
    - A生成自己的散列NodeID
    - A向B发出FindNode请求，请求A自己。
    - B将A加入对应子树的K桶，根据路由协议，B会找到离A最近的K个节点，返回给A
    - A初始化自己的K桶
    - A继续用自己收到的K个节点，完善自己的K桶，建立自己的本地路由
  - 退出

    - 直接退出，其他节点会通过探测更新路由表。

- KAD算法的优势
  a）简单
  
  二叉树，与其他某些DHT相比
  
  b）灵活，便于调整
  
  K值可以任意调整，当然越大维护成本越高，对CPU内存要求
  
  c）并发性能，可调整
  
  α参数可以任意调整，并发效率高，网络、内存
  
  d）安全性
  
  1）在线时间越长的节点，越容易加入K桶
  
  2）即便恶意节点加入，也只可能影响一棵子树，只有路由到特定子树才有可能碰到该节点
  
  3）即便路由到特定子树，有K值和路由策略决定，可能不会碰到该节点
  
  4）α参数决定并发，即使碰到也不一定信任，除非所有α个节点全部都是恶意的。这个概率很低。

- 优化空间
> 选择合适的K值与α参数参数，可以对性能及安全产生影响。

# CORAL DSHT 算法
- Coral特点
可用于解决补充DHT网络中的位置问题

- RTT时间代价等级划分
默认的是3级，L2(<20ms),L1(<60ms),L0(剩余的所有节点)。

- 路由方式概述
完整的 NodeID的节点空间仍然是由SHA-1生成的160bit，但是查找和放置的时候，不是在整个NodeID空间上查找，而是优先在L2上的节点进行 DHT查找，L2 层中找不到合适的节点再去L1层中查找，最后才是L0层。

- DHT网络代价
不过DHT只需要维护一个DHT空间，而coral则需要维护三个，显然在节点加入或离去的时候，系统地自平衡代价也要大一点的。

##  S/Kademlia 算法

- 安全扩展
S/Kademlia 扩展了Kademlia, 用于防止恶意的攻击。有如下两方面的方法：

S/Kad 提供了方案来保证NodeId的生成已经防止Sybill攻击。它需要节点产生PKI公私钥对。从中导出他们的身份，并彼此间签名。一个方案使用POW工作量证明，使得生成Sybills成本高昂。——PKI机制

![](/4.png) 

If a node receives a signed message it can now first validate its signature and then check if the crypto puzzles were solved. Both operations have O(1) complexity for a constant public key size while crypto puzzle creation has O(2c1 + 2c2 ) complexity.

S/Kad 节点在不相交的路径上查找直， 即使网络中存在大量的不诚实节点，也能确保诚实节点可以互相链接。即使网络中存在一半的不诚实节点，S/Kad 也能达到85%的成功率。

- 通俗解释PKI
区块链是这样解决的假设A是发出人，B是接收人
A只要把消息分两步加密就可以了:第一步,用A自己的私钥对原始信息做第一层加密:第二步,在上一步获得的数据基础上再用B的公钥做第二层加密。B收到这个加密的信息后,以相反的次序做两次解密操作:

第一步,用B自己的私钥解密收到的信息,得到被A的私钥加密过的信息;。这一层加密的且的是证明这个信息是由A加密并发出的,因为只有A的私钥才能完成这样的加密,这一步也叫做数字签名它排除了消息是别人伪造或者别人冒充A的可能性

第二步,在第一步获得的数据基础上用A的公钥再解密一次即得到未加密信息，加密的目的是确保信息只有B能够解密、看到未加密信息,因为只有B有解密私钥,即使别人看到了加密后的信息,也无法解密,更无法篡改。

- Kademlia算法的缺点
a）日蚀攻击，自由选择节点攻击

b）女巫攻击，大量伪造节点，一个实体对应多个节点

c）S/kademlia:一个安全的基于秘钥路由的可行方法。2007年

- S/Kademlia
a）节点签名加密

b）路由过程

c）路由表维护


